{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"RobRecSolver.jl Documentation High-level interface # RobRecSolver.runExperiments \u2014 Function . runExperiments(ns::Array{Integer}, ms::Array{Integer}; numberOfInstances = 5) Main function to run experiments Examples: julia> using RobRecSolver julia> runExperiments([100, 400, 1000], [10, 25, 100]]) source Solver Functions Incremental Problem # RobRecSolver.incrementalProblem \u2014 Function . incrementalProblem(c, \u03b1, x, X, pd) Solve incremental problem with specified costs c , parameter $\u03b1 \\in [0, 1]$, first stage solutions x and a list of constraints X defining a set of feasible solutions. source Evaluation Problem # RobRecSolver.evaluationProblem \u2014 Function . evaluationProblem(C, c, d, \u0393, \u03b1, x, X, pd) Computes EVAL(x) with accuracy \u03f5. source Recoverable Problem # RobRecSolver.recoverableProblem \u2014 Function . recoverableProblem(C, c, X, \u03b1, dg) Mathematical programming model for solving the following recoverable problem: $REC(c) = min_{x \\in X} min_{y \\in X^{\\alpha}_x} (Cx + cy)$ source Adversarial Problem # RobRecSolver.adversarialProblem \u2014 Function . adversarialProblem(C, c, d, \u0393, X, \u03b1, pd) Computes ADV(\u03f5) with accuracy \u03f5. source Selection Lower Bound # RobRecSolver.selectionLowerBound \u2014 Function . selectionLowerBound(C, c, d, \u0393, X, \u03b1, dg) Computes selection lower bound. source Lagrangian Lower Bound # RobRecSolver.lagrangianLowerBound \u2014 Function . lagrangian_lower_bound(C, c, d, \u0393, X, l, dg) Computes Lagrangian lower bound. source","title":"Home"},{"location":"#robrecsolverjl-documentation","text":"","title":"RobRecSolver.jl Documentation"},{"location":"#high-level-interface","text":"# RobRecSolver.runExperiments \u2014 Function . runExperiments(ns::Array{Integer}, ms::Array{Integer}; numberOfInstances = 5) Main function to run experiments Examples: julia> using RobRecSolver julia> runExperiments([100, 400, 1000], [10, 25, 100]]) source","title":"High-level interface"},{"location":"#solver-functions","text":"","title":"Solver Functions"},{"location":"#incremental-problem","text":"# RobRecSolver.incrementalProblem \u2014 Function . incrementalProblem(c, \u03b1, x, X, pd) Solve incremental problem with specified costs c , parameter $\u03b1 \\in [0, 1]$, first stage solutions x and a list of constraints X defining a set of feasible solutions. source","title":"Incremental Problem"},{"location":"#evaluation-problem","text":"# RobRecSolver.evaluationProblem \u2014 Function . evaluationProblem(C, c, d, \u0393, \u03b1, x, X, pd) Computes EVAL(x) with accuracy \u03f5. source","title":"Evaluation Problem"},{"location":"#recoverable-problem","text":"# RobRecSolver.recoverableProblem \u2014 Function . recoverableProblem(C, c, X, \u03b1, dg) Mathematical programming model for solving the following recoverable problem: $REC(c) = min_{x \\in X} min_{y \\in X^{\\alpha}_x} (Cx + cy)$ source","title":"Recoverable Problem"},{"location":"#adversarial-problem","text":"# RobRecSolver.adversarialProblem \u2014 Function . adversarialProblem(C, c, d, \u0393, X, \u03b1, pd) Computes ADV(\u03f5) with accuracy \u03f5. source","title":"Adversarial Problem"},{"location":"#selection-lower-bound","text":"# RobRecSolver.selectionLowerBound \u2014 Function . selectionLowerBound(C, c, d, \u0393, X, \u03b1, dg) Computes selection lower bound. source","title":"Selection Lower Bound"},{"location":"#lagrangian-lower-bound","text":"# RobRecSolver.lagrangianLowerBound \u2014 Function . lagrangian_lower_bound(C, c, d, \u0393, X, l, dg) Computes Lagrangian lower bound. source","title":"Lagrangian Lower Bound"}]}