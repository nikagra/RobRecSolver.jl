{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"RobRecSolver.jl RobRecSolver is a package written in a Julia programming language developed to test performance of algorithms proposed in Robust recoverable 0-1 optimization problems under polyhedral uncertainty (Mikita Hradovich, Adam Kasperski, Pawel Zielinski) which is available as preprint on arxiv.org . This work will later be referenced as publication . Installing RobRecSolver If you are familiar with Julia you can quickly install RobRecSolver and CPLEX: julia> Pkg.add(\"CPLEX\") julia> Pkg.clone(\"https://github.com/nikagra/RobRecSolver.jl.git\") Note: You need a working installation of CPLEX Optimizer. See Getting CPLEX Optimizer for more information. Contents Installation Guide Getting Julia Getting CPLEX Optimizer Getting RobRecSolver Updating RobRecSolver Reference Problems Incremental Problem Evaluation Problem Recoverable Problem Adversarial Problem Selection Lower Bound Lagrangian Lower Bound Additional Types and functions Utilities Experiments Problems Testing Framework Citing You can cite the publication by using the following BibTeX snippet: @article{hradovich2018robust, title={Robust recoverable 0-1 optimization problems under polyhedral uncertainty}, author={Hradovich, Mikita and Kasperski, Adam and Zielinski, Pawel}, journal={arXiv preprint arXiv:1811.06719}, year={2018} }","title":"Home"},{"location":"#robrecsolverjl","text":"RobRecSolver is a package written in a Julia programming language developed to test performance of algorithms proposed in Robust recoverable 0-1 optimization problems under polyhedral uncertainty (Mikita Hradovich, Adam Kasperski, Pawel Zielinski) which is available as preprint on arxiv.org . This work will later be referenced as publication .","title":"RobRecSolver.jl"},{"location":"#installing-robrecsolver","text":"If you are familiar with Julia you can quickly install RobRecSolver and CPLEX: julia> Pkg.add(\"CPLEX\") julia> Pkg.clone(\"https://github.com/nikagra/RobRecSolver.jl.git\") Note: You need a working installation of CPLEX Optimizer. See Getting CPLEX Optimizer for more information.","title":"Installing RobRecSolver"},{"location":"#contents","text":"Installation Guide Getting Julia Getting CPLEX Optimizer Getting RobRecSolver Updating RobRecSolver Reference Problems Incremental Problem Evaluation Problem Recoverable Problem Adversarial Problem Selection Lower Bound Lagrangian Lower Bound Additional Types and functions Utilities Experiments Problems Testing Framework","title":"Contents"},{"location":"#citing","text":"You can cite the publication by using the following BibTeX snippet: @article{hradovich2018robust, title={Robust recoverable 0-1 optimization problems under polyhedral uncertainty}, author={Hradovich, Mikita and Kasperski, Adam and Zielinski, Pawel}, journal={arXiv preprint arXiv:1811.06719}, year={2018} }","title":"Citing"},{"location":"apireference/","text":"Reference Problems Incremental Problem # RobRecSolver.incrementalProblem \u2014 Function . incrementalProblem(c, \u03b1, x, X, pd) Solves incremental problem with specified costs c , parameter $\u03b1 \\in [0, 1]$, first stage solutions x and a list of constraints X defining a set of feasible solutions. It is subproblem of of evaluationProblem and adversarialProblem . Check section 4 Solving the problems by MIP formulations of publication for more information about this algorithm. Arguments c : is a vector of a nonnegative nominal second stage costs. \u03b1 : fixed number belonging to $[0, 1]$ x : first stage solution. X : is a set of feasible solutions represented as a list functions, each of which accepts a list of JuMP variables as an argument and returns a JuMP linear constraint. pd : an instance of ProblemDescriptor source Evaluation Problem # RobRecSolver.evaluationProblem \u2014 Function . evaluationProblem(C, c, d, \u0393, \u03b1, x, X, pd) Computes $Eval(\\pmb{x})$ with accuracy \u03f5. Check section 4 Solving the problems by MIP formulations of publication for more information about this algorithm. Arguments C : is a vector of nonnegative first stage costs. c : is a vector of a nonnegative nominal second stage costs. d : is a vector of maximal deviations of the costs from their nominal values. \u0393 : is a budget, or the amount of uncertainty, which can be allocated to the second stage costs. X : is a set of feasible solutions represented as a list functions, each of which accepts a list of JuMP variables as an argument and returns a JuMP linear constraint. \u03b1 : fixed number belonging to $[0, 1]$ pd : an instance of ProblemDescriptor source Recoverable Problem # RobRecSolver.recoverableProblem \u2014 Function . recoverableProblem(C, c, X, \u03b1, dg) Solves recoverable problem $REC(c) = min_{x \\in X} min_{y \\in X^{\\alpha}_x} (Cx + cy)$. Check section 4 Solving the problems by MIP formulations of publication for more information about this algorithm. Arguments C : is a vector of nonnegative first stage costs. c : is a vector of a nonnegative nominal second stage costs. X : is a set of feasible solutions represented as a list functions, each of which accepts a list of JuMP variables as an argument and returns a JuMP linear constraint. \u03b1 : fixed number belonging to $[0, 1]$ pd : an instance of ProblemDescriptor source Adversarial Problem # RobRecSolver.adversarialProblem \u2014 Function . adversarialProblem(C, c, d, \u0393, X, \u03b1, pd) Computes $Adv$ with accuracy \u03f5. Check section 5.1 Adversarial lower bound of publication for more information about this algorithm. Arguments C : is a vector of nonnegative first stage costs. c : is a vector of a nonnegative nominal second stage costs. d : is a vector of maximal deviations of the costs from their nominal values. \u0393 : is a budget, or the amount of uncertainty, which can be allocated to the second stage costs. X : is a set of feasible solutions represented as a list functions, each of which accepts a list of JuMP variables as an argument and returns a JuMP linear constraint. \u03b1 : fixed number belonging to $[0, 1]$ pd : an instance of ProblemDescriptor source Selection Lower Bound # RobRecSolver.selectionLowerBound \u2014 Function . selectionLowerBound(C, c, d, \u0393, X, \u03b1, dg) Computes selection lower bound. Check section 5.2 Selection lower bound of publication for more information about this algorithm. Arguments C : is a vector of nonnegative first stage costs. c : is a vector of a nonnegative nominal second stage costs. d : is a vector of maximal deviations of the costs from their nominal values. \u0393 : is a budget, or the amount of uncertainty, which can be allocated to the second stage costs. X : is a set of feasible solutions represented as a list functions, each of which accepts a list of JuMP variables as an argument and returns a JuMP linear constraint. \u03b1 : fixed number belonging to $[0, 1]$ pd : an instance of ProblemDescriptor source Lagrangian Lower Bound # RobRecSolver.lagrangianLowerBound \u2014 Function . lagrangian_lower_bound(C, c, d, \u0393, X, l, dg) Computes Lagrangian lower bound. Check section 5.3 Lagrangian lower bound of publication for more information about this algorithm. Arguments C : is a vector of nonnegative first stage costs. c : is a vector of a nonnegative nominal second stage costs. d : is a vector of maximal deviations of the costs from their nominal values. \u0393 : is a budget, or the amount of uncertainty, which can be allocated to the second stage costs. X : is a set of feasible solutions represented as a list functions, each of which accepts a list of JuMP variables as an argument and returns a JuMP linear constraint. l : value of parameter $l=\\lceil m(1-\\alpha) \\rceil$ pd : an instance of ProblemDescriptor source Additional Types and functions There is a number of types and helper functions defined to facilitate implementation of algorithms described in publication . # RobRecSolver.ProblemDescriptor \u2014 Type . Base type for all problem descriptors. It is expected to has the following fields: n : the size of the problem. saneComputationLimit : maximum size of the problem for which computing results for adversarial lower bound, recoverable lower bound, selection lower bound or lagrangian lower bound makes sense. equalCardinalityProperty : specifies if problem possess equal cardinality property. cardinality : cardinality of the problem if any. source # RobRecSolver.KnapsackProblemDescriptor \u2014 Type . KnapsackProblemDescriptor is an implementation ProblemDescriptor for minimum knapsack problem. source # RobRecSolver.AssignmentProblemDescriptor \u2014 Type . AssignmentProblemDescriptor is an implementation ProblemDescriptor for minimum assignment problem. source # RobRecSolver.getProblemSize \u2014 Function . getProblemSize(pd::ProblemDescriptor) Returns the size of the problem. Arguments pd : an instance of ProblemDescriptor source # RobRecSolver.getSaneComputationLimit \u2014 Function . getSaneComputationLimit(pd::ProblemDescriptor) Returns maximum size of the problem for which computing results for adversarial lower bound, recoverable lower bound, selection lower bound or lagrangian lower bound makes sense. Arguments pd : an instance of ProblemDescriptor source # RobRecSolver.hasEqualCardinalityProperty \u2014 Function . hasEqualCardinalityProperty(pd::ProblemDescriptor) Returns whether the problem possess equal cardinality property. Arguments pd : an instance of ProblemDescriptor source # RobRecSolver.getCardinality \u2014 Function . getCardinality(pd::ProblemDescriptor) Returns cardinality of the problem if any. Arguments pd : an instance of ProblemDescriptor source # RobRecSolver.initialScenario \u2014 Function . initialScenario(c, d, \u0393) Returns a good initial scenario $c_0$. It is used in computation of evaluationProblem and adversarialProblem . Check section 5.1 Adversarial lower bound of publication for more information about this algorithm. Arguments c : vector of nonnegative nominal second stage costs. d : vector of maximal deviations of the costs from their nominal values. \u0393 : budget, or the amount of uncertainty, which can be allocated to the second stage costs source Utilities The functions below allow customize package parameters like solver time limits or logging for different algorithms. # RobRecSolver.loadProperties \u2014 Function . loadProperties() Loads properties stored in an INI file from the specified file location. To change default location set ROBRECSOLVER_CONFIG environment variable either in Julia REPL or in ~/.julia/config/startup.jl and then reload RobRecSolver package: julia> ENV[ROBRECSOLVER_CONFIG] = \"<path_to_file>\" julia> Pkg.reload(\"RobRecSolver\") Use default properties file Pkg.dir(\"RobRecSolver\")/conf/config.ini as a reference. In order to reset changes simply delete environment variable and reload RobRecSolver package. source # RobRecSolver.getProperty \u2014 Function . getProperty(parameter[, parameterType, section]) Get value for key of name parameter of type parameterType from section section from either default properties files or the one specified with a path in ROBRECSOLVER_CONFIG . Argument parameterType defaults to Int and section defaults to main . source","title":"Reference"},{"location":"apireference/#reference","text":"","title":"Reference"},{"location":"apireference/#problems","text":"","title":"Problems"},{"location":"apireference/#incremental-problem","text":"# RobRecSolver.incrementalProblem \u2014 Function . incrementalProblem(c, \u03b1, x, X, pd) Solves incremental problem with specified costs c , parameter $\u03b1 \\in [0, 1]$, first stage solutions x and a list of constraints X defining a set of feasible solutions. It is subproblem of of evaluationProblem and adversarialProblem . Check section 4 Solving the problems by MIP formulations of publication for more information about this algorithm. Arguments c : is a vector of a nonnegative nominal second stage costs. \u03b1 : fixed number belonging to $[0, 1]$ x : first stage solution. X : is a set of feasible solutions represented as a list functions, each of which accepts a list of JuMP variables as an argument and returns a JuMP linear constraint. pd : an instance of ProblemDescriptor source","title":"Incremental Problem"},{"location":"apireference/#evaluation-problem","text":"# RobRecSolver.evaluationProblem \u2014 Function . evaluationProblem(C, c, d, \u0393, \u03b1, x, X, pd) Computes $Eval(\\pmb{x})$ with accuracy \u03f5. Check section 4 Solving the problems by MIP formulations of publication for more information about this algorithm. Arguments C : is a vector of nonnegative first stage costs. c : is a vector of a nonnegative nominal second stage costs. d : is a vector of maximal deviations of the costs from their nominal values. \u0393 : is a budget, or the amount of uncertainty, which can be allocated to the second stage costs. X : is a set of feasible solutions represented as a list functions, each of which accepts a list of JuMP variables as an argument and returns a JuMP linear constraint. \u03b1 : fixed number belonging to $[0, 1]$ pd : an instance of ProblemDescriptor source","title":"Evaluation Problem"},{"location":"apireference/#recoverable-problem","text":"# RobRecSolver.recoverableProblem \u2014 Function . recoverableProblem(C, c, X, \u03b1, dg) Solves recoverable problem $REC(c) = min_{x \\in X} min_{y \\in X^{\\alpha}_x} (Cx + cy)$. Check section 4 Solving the problems by MIP formulations of publication for more information about this algorithm. Arguments C : is a vector of nonnegative first stage costs. c : is a vector of a nonnegative nominal second stage costs. X : is a set of feasible solutions represented as a list functions, each of which accepts a list of JuMP variables as an argument and returns a JuMP linear constraint. \u03b1 : fixed number belonging to $[0, 1]$ pd : an instance of ProblemDescriptor source","title":"Recoverable Problem"},{"location":"apireference/#adversarial-problem","text":"# RobRecSolver.adversarialProblem \u2014 Function . adversarialProblem(C, c, d, \u0393, X, \u03b1, pd) Computes $Adv$ with accuracy \u03f5. Check section 5.1 Adversarial lower bound of publication for more information about this algorithm. Arguments C : is a vector of nonnegative first stage costs. c : is a vector of a nonnegative nominal second stage costs. d : is a vector of maximal deviations of the costs from their nominal values. \u0393 : is a budget, or the amount of uncertainty, which can be allocated to the second stage costs. X : is a set of feasible solutions represented as a list functions, each of which accepts a list of JuMP variables as an argument and returns a JuMP linear constraint. \u03b1 : fixed number belonging to $[0, 1]$ pd : an instance of ProblemDescriptor source","title":"Adversarial Problem"},{"location":"apireference/#selection-lower-bound","text":"# RobRecSolver.selectionLowerBound \u2014 Function . selectionLowerBound(C, c, d, \u0393, X, \u03b1, dg) Computes selection lower bound. Check section 5.2 Selection lower bound of publication for more information about this algorithm. Arguments C : is a vector of nonnegative first stage costs. c : is a vector of a nonnegative nominal second stage costs. d : is a vector of maximal deviations of the costs from their nominal values. \u0393 : is a budget, or the amount of uncertainty, which can be allocated to the second stage costs. X : is a set of feasible solutions represented as a list functions, each of which accepts a list of JuMP variables as an argument and returns a JuMP linear constraint. \u03b1 : fixed number belonging to $[0, 1]$ pd : an instance of ProblemDescriptor source","title":"Selection Lower Bound"},{"location":"apireference/#lagrangian-lower-bound","text":"# RobRecSolver.lagrangianLowerBound \u2014 Function . lagrangian_lower_bound(C, c, d, \u0393, X, l, dg) Computes Lagrangian lower bound. Check section 5.3 Lagrangian lower bound of publication for more information about this algorithm. Arguments C : is a vector of nonnegative first stage costs. c : is a vector of a nonnegative nominal second stage costs. d : is a vector of maximal deviations of the costs from their nominal values. \u0393 : is a budget, or the amount of uncertainty, which can be allocated to the second stage costs. X : is a set of feasible solutions represented as a list functions, each of which accepts a list of JuMP variables as an argument and returns a JuMP linear constraint. l : value of parameter $l=\\lceil m(1-\\alpha) \\rceil$ pd : an instance of ProblemDescriptor source","title":"Lagrangian Lower Bound"},{"location":"apireference/#additional-types-and-functions","text":"There is a number of types and helper functions defined to facilitate implementation of algorithms described in publication . # RobRecSolver.ProblemDescriptor \u2014 Type . Base type for all problem descriptors. It is expected to has the following fields: n : the size of the problem. saneComputationLimit : maximum size of the problem for which computing results for adversarial lower bound, recoverable lower bound, selection lower bound or lagrangian lower bound makes sense. equalCardinalityProperty : specifies if problem possess equal cardinality property. cardinality : cardinality of the problem if any. source # RobRecSolver.KnapsackProblemDescriptor \u2014 Type . KnapsackProblemDescriptor is an implementation ProblemDescriptor for minimum knapsack problem. source # RobRecSolver.AssignmentProblemDescriptor \u2014 Type . AssignmentProblemDescriptor is an implementation ProblemDescriptor for minimum assignment problem. source # RobRecSolver.getProblemSize \u2014 Function . getProblemSize(pd::ProblemDescriptor) Returns the size of the problem. Arguments pd : an instance of ProblemDescriptor source # RobRecSolver.getSaneComputationLimit \u2014 Function . getSaneComputationLimit(pd::ProblemDescriptor) Returns maximum size of the problem for which computing results for adversarial lower bound, recoverable lower bound, selection lower bound or lagrangian lower bound makes sense. Arguments pd : an instance of ProblemDescriptor source # RobRecSolver.hasEqualCardinalityProperty \u2014 Function . hasEqualCardinalityProperty(pd::ProblemDescriptor) Returns whether the problem possess equal cardinality property. Arguments pd : an instance of ProblemDescriptor source # RobRecSolver.getCardinality \u2014 Function . getCardinality(pd::ProblemDescriptor) Returns cardinality of the problem if any. Arguments pd : an instance of ProblemDescriptor source # RobRecSolver.initialScenario \u2014 Function . initialScenario(c, d, \u0393) Returns a good initial scenario $c_0$. It is used in computation of evaluationProblem and adversarialProblem . Check section 5.1 Adversarial lower bound of publication for more information about this algorithm. Arguments c : vector of nonnegative nominal second stage costs. d : vector of maximal deviations of the costs from their nominal values. \u0393 : budget, or the amount of uncertainty, which can be allocated to the second stage costs source","title":"Additional Types and functions"},{"location":"apireference/#utilities","text":"The functions below allow customize package parameters like solver time limits or logging for different algorithms. # RobRecSolver.loadProperties \u2014 Function . loadProperties() Loads properties stored in an INI file from the specified file location. To change default location set ROBRECSOLVER_CONFIG environment variable either in Julia REPL or in ~/.julia/config/startup.jl and then reload RobRecSolver package: julia> ENV[ROBRECSOLVER_CONFIG] = \"<path_to_file>\" julia> Pkg.reload(\"RobRecSolver\") Use default properties file Pkg.dir(\"RobRecSolver\")/conf/config.ini as a reference. In order to reset changes simply delete environment variable and reload RobRecSolver package. source # RobRecSolver.getProperty \u2014 Function . getProperty(parameter[, parameterType, section]) Get value for key of name parameter of type parameterType from section section from either default properties files or the one specified with a path in ROBRECSOLVER_CONFIG . Argument parameterType defaults to Int and section defaults to main . source","title":"Utilities"},{"location":"experiments/","text":"Experiments Problems # RobRecSolver.minimumKnapsackProblem \u2014 Function . minimumKnapsackProblem(C, w, W) Solve minimum knapsack problem using vector of costs C , weights w and overall weight limit W . source # RobRecSolver.getKnapsackConstraints \u2014 Function . getKnapsackConstraints(w, W) Return a list of constraints defining a set of feasible solutions of a minimum knapsack problem. Each constraint is function with one parameter, which is variable of a mathematical programming model. source # RobRecSolver.minimumAssignmentProblem \u2014 Function . minimumAssignmentProblem(C) Solve minimum assignment problem using vector of costs C . source # RobRecSolver.getAssignmentConstraints \u2014 Function . getAssignmentConstraints(m) Return a list of constraints defining a set of feasible solutions of a minimum assignment problem. Each constraint is function with one parameter, which is variable of a mathematical programming model. source Testing Framework # RobRecSolver.Experiments \u2014 Module . RobRecSolver.Experiments is a module containing all of the code regarding conduction of experiments. source # RobRecSolver.Experiments.generateData \u2014 Function . generateData(problemDescriptor::ProblemDescriptor) Helper function designed to generate experiment data for each problem under consideration. It returns a tuple (C, c, d, \u0393, X) where C is a vector of nonnegative first stage costs c is a vector of a nonnegative nominal second stage costs d is a vector of maximal deviations of the costs from their nominal values \u0393 is a budget, or the amount of uncertainty, which can be allocated to the second stage costs X is a set of feasible solutions represented as a list functions, each of which accepts a list of JuMP variables as an argument and returns a JuMP linear constraint source # RobRecSolver.Experiments.runExperiments \u2014 Function . runExperiments(ns::Array{Integer}, ms::Array{Integer}; \u03b1s = collect(0.1:0.1:0.9), numberOfInstances = 5) Entry point of experiments. This function runs experiments for minimum knapsack problem with problem size n specified by the list ns and minimum assignment problem with problem size m specified by the list ms . Optional argument \u03b1s specify a list of parameters defining neighbourhood of some solution $x$ and optional argument numberOfInstances specify number of problem instances to be generated for each value of alpha . Examples: julia> using RobRecSolver.Experiments julia> runExperiments([100, 400, 1000], [10, 25, 100]) source # RobRecSolver.Experiments.runKnapsackExperiments \u2014 Function . runKnapsackExperiments(ns; \u03b1s = collect(0.1:0.1:0.9), numberOfInstances = 5) Runs experiments for minimum knapsack problem. source # RobRecSolver.Experiments.runAssignmentExperiments \u2014 Function . runAssignmentExperiments(ms; \u03b1s = collect(0.1:0.1:0.9), numberOfInstances = 5) Runs experiments for minimum assignment problem. source # RobRecSolver.Experiments.exportKnapsackResults \u2014 Function . exportKnapsackResults(problemDescriptor, \u03b1s, results) Saves results of minimum knapsack problem experiments to CSV files and as PDF plots. Arguments problemDescriptor::ProblemDescriptor : implementation of ProblemDescriptor for this problem. \u03b1s::Array{Integer, 1} : list of values of \u03b1. results::Array{Float64, 1} : three-dimentional array of results, where first dimention specify problem, second dimention specify ratios or times results, the third one contain results for each value of \u03b1. source # RobRecSolver.Experiments.exportAssignmentResults \u2014 Function . exportAssignmentResults(problemDescriptor, \u03b1s, results) Saves results of minimum assignment problem experiments to CSV files and as PDF plots. Arguments problemDescriptor::ProblemDescriptor : implementation of ProblemDescriptor for this problem. \u03b1s::Array{Integer, 1} : list of values of \u03b1. results::Array{Float64, 1} : three-dimentional array of results, where first dimention specify problem, second dimention specify ratios or times results, the third one contain results for each value of \u03b1. source # RobRecSolver.Experiments.saveCsv \u2014 Function . saveCsv(filename, data, columnNames) Saves data described by columnNames to CSV file with name filename . Examples: julia> using RobRecSolver julia> Experiments.saveCsv(\"item_prices.csv\", [\"milk\" 100; \"ham\" 250], [\"item\", \"price\"]) The above command will create file item_prices.csv with the following content: item,price milk,100 ham,250 source # RobRecSolver.Experiments.drawAndSavePlot \u2014 Function . drawAndSavePlot(filename, x, ys, xlabel, ylabel, yslabels; linewidth=2, linestyles = [:solid :dash :dashdot :dot :solid], shape = [:diamond :pentagon :star4 :utriangle :square], palette=cgrad([:black, :grey]), annotations = []) Draws plot and saves it to PDF file with name filename . Here x is a values of 0X axis, ys is a columns of series, xlabel is label of 0X axis, ylabel is label of 0Y axis and yslabels is a labels of individual series. Examples: julia> using RobRecSolver, Plots julia> pyplot() julia> Experiments.drawAndSavePlot(\"plot.pdf\", [0.1, 0.2, 0.3], [21, 15, 12], \"\u03b1\", \"average time (s)\", \"m=100\") The above command will draw the plot shown below and save it as plot.pdf . The rest of the arguments function uses is self-descriptive and is based on the ones from the Plots.jl package. Default values of arguments are adjusted to the needs of the publication . source","title":"Experiments"},{"location":"experiments/#experiments","text":"","title":"Experiments"},{"location":"experiments/#problems","text":"# RobRecSolver.minimumKnapsackProblem \u2014 Function . minimumKnapsackProblem(C, w, W) Solve minimum knapsack problem using vector of costs C , weights w and overall weight limit W . source # RobRecSolver.getKnapsackConstraints \u2014 Function . getKnapsackConstraints(w, W) Return a list of constraints defining a set of feasible solutions of a minimum knapsack problem. Each constraint is function with one parameter, which is variable of a mathematical programming model. source # RobRecSolver.minimumAssignmentProblem \u2014 Function . minimumAssignmentProblem(C) Solve minimum assignment problem using vector of costs C . source # RobRecSolver.getAssignmentConstraints \u2014 Function . getAssignmentConstraints(m) Return a list of constraints defining a set of feasible solutions of a minimum assignment problem. Each constraint is function with one parameter, which is variable of a mathematical programming model. source","title":"Problems"},{"location":"experiments/#testing-framework","text":"# RobRecSolver.Experiments \u2014 Module . RobRecSolver.Experiments is a module containing all of the code regarding conduction of experiments. source # RobRecSolver.Experiments.generateData \u2014 Function . generateData(problemDescriptor::ProblemDescriptor) Helper function designed to generate experiment data for each problem under consideration. It returns a tuple (C, c, d, \u0393, X) where C is a vector of nonnegative first stage costs c is a vector of a nonnegative nominal second stage costs d is a vector of maximal deviations of the costs from their nominal values \u0393 is a budget, or the amount of uncertainty, which can be allocated to the second stage costs X is a set of feasible solutions represented as a list functions, each of which accepts a list of JuMP variables as an argument and returns a JuMP linear constraint source # RobRecSolver.Experiments.runExperiments \u2014 Function . runExperiments(ns::Array{Integer}, ms::Array{Integer}; \u03b1s = collect(0.1:0.1:0.9), numberOfInstances = 5) Entry point of experiments. This function runs experiments for minimum knapsack problem with problem size n specified by the list ns and minimum assignment problem with problem size m specified by the list ms . Optional argument \u03b1s specify a list of parameters defining neighbourhood of some solution $x$ and optional argument numberOfInstances specify number of problem instances to be generated for each value of alpha . Examples: julia> using RobRecSolver.Experiments julia> runExperiments([100, 400, 1000], [10, 25, 100]) source # RobRecSolver.Experiments.runKnapsackExperiments \u2014 Function . runKnapsackExperiments(ns; \u03b1s = collect(0.1:0.1:0.9), numberOfInstances = 5) Runs experiments for minimum knapsack problem. source # RobRecSolver.Experiments.runAssignmentExperiments \u2014 Function . runAssignmentExperiments(ms; \u03b1s = collect(0.1:0.1:0.9), numberOfInstances = 5) Runs experiments for minimum assignment problem. source # RobRecSolver.Experiments.exportKnapsackResults \u2014 Function . exportKnapsackResults(problemDescriptor, \u03b1s, results) Saves results of minimum knapsack problem experiments to CSV files and as PDF plots. Arguments problemDescriptor::ProblemDescriptor : implementation of ProblemDescriptor for this problem. \u03b1s::Array{Integer, 1} : list of values of \u03b1. results::Array{Float64, 1} : three-dimentional array of results, where first dimention specify problem, second dimention specify ratios or times results, the third one contain results for each value of \u03b1. source # RobRecSolver.Experiments.exportAssignmentResults \u2014 Function . exportAssignmentResults(problemDescriptor, \u03b1s, results) Saves results of minimum assignment problem experiments to CSV files and as PDF plots. Arguments problemDescriptor::ProblemDescriptor : implementation of ProblemDescriptor for this problem. \u03b1s::Array{Integer, 1} : list of values of \u03b1. results::Array{Float64, 1} : three-dimentional array of results, where first dimention specify problem, second dimention specify ratios or times results, the third one contain results for each value of \u03b1. source # RobRecSolver.Experiments.saveCsv \u2014 Function . saveCsv(filename, data, columnNames) Saves data described by columnNames to CSV file with name filename . Examples: julia> using RobRecSolver julia> Experiments.saveCsv(\"item_prices.csv\", [\"milk\" 100; \"ham\" 250], [\"item\", \"price\"]) The above command will create file item_prices.csv with the following content: item,price milk,100 ham,250 source # RobRecSolver.Experiments.drawAndSavePlot \u2014 Function . drawAndSavePlot(filename, x, ys, xlabel, ylabel, yslabels; linewidth=2, linestyles = [:solid :dash :dashdot :dot :solid], shape = [:diamond :pentagon :star4 :utriangle :square], palette=cgrad([:black, :grey]), annotations = []) Draws plot and saves it to PDF file with name filename . Here x is a values of 0X axis, ys is a columns of series, xlabel is label of 0X axis, ylabel is label of 0Y axis and yslabels is a labels of individual series. Examples: julia> using RobRecSolver, Plots julia> pyplot() julia> Experiments.drawAndSavePlot(\"plot.pdf\", [0.1, 0.2, 0.3], [21, 15, 12], \"\u03b1\", \"average time (s)\", \"m=100\") The above command will draw the plot shown below and save it as plot.pdf . The rest of the arguments function uses is self-descriptive and is based on the ones from the Plots.jl package. Default values of arguments are adjusted to the needs of the publication . source","title":"Testing Framework"},{"location":"installation/","text":"Installation Guide This guide will briefly guide you through installing Julia, CPLEX Optimizer and RobRecSolver with all of its dependencies. Getting Julia Version of Julia required by JuMP and consequently by RobRecSolver is 0.6 . You can build Julia from source or use the binaries. Download links and more detailed instructions are available on the Julia website. Getting CPLEX Optimizer RobRecSolver package depends on CPLEX.jl which in turn requires a working installation of CPLEX Optimizer with a license, which is free for faculty members and graduate teaching assistants. CPLEX Optimizer must be downloaded and installed separately. Check CPLEX.jl for further instructions. Getting RobRecSolver RobRecSolver package is not yet registered in the METADATA.jl repository. To install it, use Pkg.clone command: julia> Pkg.clone(\"https://github.com/nikagra/RobRecSolver.jl.git\") Since RobRecSolver contains REQUIRE file, that file will be used to determine which registered packages RobRecSolver depends on, and they will be automatically installed. Updating RobRecSolver In order to update package run the following sequence of commands ( ; symbol at the start of the Julia's REPL enters shell mode): julia> cd(Pkg.dir(\"RobRecSolver\")) julia> ; shell> git fetch --all --tags --prune && git checkout tags/<version> julia> Pkg.resolve()","title":"Installation Guide"},{"location":"installation/#installation-guide","text":"This guide will briefly guide you through installing Julia, CPLEX Optimizer and RobRecSolver with all of its dependencies.","title":"Installation Guide"},{"location":"installation/#getting-julia","text":"Version of Julia required by JuMP and consequently by RobRecSolver is 0.6 . You can build Julia from source or use the binaries. Download links and more detailed instructions are available on the Julia website.","title":"Getting Julia"},{"location":"installation/#getting-cplex-optimizer","text":"RobRecSolver package depends on CPLEX.jl which in turn requires a working installation of CPLEX Optimizer with a license, which is free for faculty members and graduate teaching assistants. CPLEX Optimizer must be downloaded and installed separately. Check CPLEX.jl for further instructions.","title":"Getting CPLEX Optimizer"},{"location":"installation/#getting-robrecsolver","text":"RobRecSolver package is not yet registered in the METADATA.jl repository. To install it, use Pkg.clone command: julia> Pkg.clone(\"https://github.com/nikagra/RobRecSolver.jl.git\") Since RobRecSolver contains REQUIRE file, that file will be used to determine which registered packages RobRecSolver depends on, and they will be automatically installed.","title":"Getting RobRecSolver"},{"location":"installation/#updating-robrecsolver","text":"In order to update package run the following sequence of commands ( ; symbol at the start of the Julia's REPL enters shell mode): julia> cd(Pkg.dir(\"RobRecSolver\")) julia> ; shell> git fetch --all --tags --prune && git checkout tags/<version> julia> Pkg.resolve()","title":"Updating RobRecSolver"}]}