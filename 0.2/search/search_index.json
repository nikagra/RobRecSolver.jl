{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"RobRecSolver.jl Documentation RobRecSolver.jl Documentation Algorithms Experiments Utilities # RobRecSolver \u2014 Module . RobRecSolver is a Julia programming language package developed to test performance of algorithms proposed in Robust recoverable 0-1 optimization problems under polyhedral uncertainty (Mikita Hradovich, Adam Kasperski, Pawel Zielinski) which is available as preprint on arxiv.org . This work will later be referenced as publication . source Algorithms There is a number of types and helper functions defined to facilitate implementation of algorithms of algorithms described in paper. # RobRecSolver.ProblemDescriptor \u2014 Type . Base type for all problem descriptors. It is expected to has the following fields: n : the size of the problem. saneComputationLimit : maximum size of the problem for which computing results for adversarial lower bound, recoverable lower bound, selection lower bound or lagrangian lower bound makes sense. equalCardinalityProperty : specifies if problem possess equal cardinality property. cardinality : cardinality of the problem if any. source # RobRecSolver.KnapsackProblemDescriptor \u2014 Type . KnapsackProblemDescriptor is an implementation ProblemDescriptor for minmium knapsack problem. source # RobRecSolver.AssignmentProblemDescriptor \u2014 Type . AssignmentProblemDescriptor is an implementation ProblemDescriptor for minmium assignment problem. source # RobRecSolver.getProblemSize \u2014 Function . getProblemSize(pd::ProblemDescriptor) Returns the size of the problem. Arguments pd : instance of ProblemDescriptor source # RobRecSolver.getSaneComputationLimit \u2014 Function . getSaneComputationLimit(pd::ProblemDescriptor) Returns maximum size of the problem for which computing results for adversarial lower bound, recoverable lower bound, selection lower bound or lagrangian lower bound makes sense. Arguments pd : instance of ProblemDescriptor source # RobRecSolver.hasEqualCardinalityProperty \u2014 Function . hasEqualCardinalityProperty(pd::ProblemDescriptor) Returns whether the problem possess equal cardinality property. Arguments pd : instance of ProblemDescriptor source # RobRecSolver.getCardinality \u2014 Function . getCardinality(pd::ProblemDescriptor) Returns cardinality of the problem if any. Arguments pd : instance of ProblemDescriptor source # RobRecSolver.initialScenario \u2014 Function . initialScenario(c, d, \u0393) Returns a good initial scenario $c_0$. It is used in computation of evaluationProblem and adversarialProblem . Check section 5.1 Adversarial lower bound of publication for more information about this algorithm. Arguments c : vector of nonnegative nominal second stage costs. d : vector of maximal deviations of the costs from their nominal values. \u0393 : budget, or the amount of uncertainty, which can be allocated to the second stage costs source Incremental Problem # RobRecSolver.incrementalProblem \u2014 Function . incrementalProblem(c, \u03b1, x, X, pd) Solves incremental problem with specified costs c , parameter $\u03b1 \\in [0, 1]$, first stage solutions x and a list of constraints X defining a set of feasible solutions. It is subproblem of of evaluationProblem and adversarialProblem . Check section 4 Solving the problems by MIP formulations of publication for more information about this algorithm. Arguments c : is a vector of a nonnegative nominal second stage costs. \u03b1 : fixed number belonging to $[0, 1]$ x : first stage solution. X : is a set of feasible solutions represented as a list functions, each of which accepts a list of JuMP variables as an argument and returns a JuMP linear constraint. pd : instance of ProblemDescriptor source Evaluation Problem # RobRecSolver.evaluationProblem \u2014 Function . evaluationProblem(C, c, d, \u0393, \u03b1, x, X, pd) Computes Eval with accuracy \u03f5. Check section 4 Solving the problems by MIP formulations of publication for more information about this algorithm. Arguments C : is a vector of nonnegative first stage costs. c : is a vector of a nonnegative nominal second stage costs. d : is a vector of maximal deviations of the costs from their nominal values. \u0393 : is a budget, or the amount of uncertainty, which can be allocated to the second stage costs. X : is a set of feasible solutions represented as a list functions, each of which accepts a list of JuMP variables as an argument and returns a JuMP linear constraint. \u03b1 : fixed number belonging to $[0, 1]$ pd : instance of ProblemDescriptor source Recoverable Problem # RobRecSolver.recoverableProblem \u2014 Function . recoverableProblem(C, c, X, \u03b1, dg) Solves recoverable problem $REC(c) = min_{x \\in X} min_{y \\in X^{\\alpha}_x} (Cx + cy)$. Check section 4 Solving the problems by MIP formulations of publication for more information about this algorithm. Arguments C : is a vector of nonnegative first stage costs. c : is a vector of a nonnegative nominal second stage costs. X : is a set of feasible solutions represented as a list functions, each of which accepts a list of JuMP variables as an argument and returns a JuMP linear constraint. \u03b1 : fixed number belonging to $[0, 1]$ pd : instance of ProblemDescriptor source Adversarial Problem # RobRecSolver.adversarialProblem \u2014 Function . adversarialProblem(C, c, d, \u0393, X, \u03b1, pd) Computes Adv with accuracy \u03f5. Check section 5.1 Adversarial lower bound of publication for more information about this algorithm. Arguments C : is a vector of nonnegative first stage costs. c : is a vector of a nonnegative nominal second stage costs. d : is a vector of maximal deviations of the costs from their nominal values. \u0393 : is a budget, or the amount of uncertainty, which can be allocated to the second stage costs. X : is a set of feasible solutions represented as a list functions, each of which accepts a list of JuMP variables as an argument and returns a JuMP linear constraint. \u03b1 : fixed number belonging to $[0, 1]$ pd : instance of ProblemDescriptor source Selection Lower Bound # RobRecSolver.selectionLowerBound \u2014 Function . selectionLowerBound(C, c, d, \u0393, X, \u03b1, dg) Computes selection lower bound. Check section 5.2 Selection lower bound of publication for more information about this algorithm. Arguments C : is a vector of nonnegative first stage costs. c : is a vector of a nonnegative nominal second stage costs. d : is a vector of maximal deviations of the costs from their nominal values. \u0393 : is a budget, or the amount of uncertainty, which can be allocated to the second stage costs. X : is a set of feasible solutions represented as a list functions, each of which accepts a list of JuMP variables as an argument and returns a JuMP linear constraint. \u03b1 : fixed number belonging to $[0, 1]$ pd : instance of ProblemDescriptor source Lagrangian Lower Bound # RobRecSolver.lagrangianLowerBound \u2014 Function . lagrangian_lower_bound(C, c, d, \u0393, X, l, dg) Computes Lagrangian lower bound. Check section 5.3 Lagrangian lower bound of publication for more information about this algorithm. Arguments C : is a vector of nonnegative first stage costs. c : is a vector of a nonnegative nominal second stage costs. d : is a vector of maximal deviations of the costs from their nominal values. \u0393 : is a budget, or the amount of uncertainty, which can be allocated to the second stage costs. X : is a set of feasible solutions represented as a list functions, each of which accepts a list of JuMP variables as an argument and returns a JuMP linear constraint. l : value of parameter $l=\\lceil m(1-\\alpha) \\rceil$ pd : instance of ProblemDescriptor source Experiments Problems # RobRecSolver.minimumKnapsackProblem \u2014 Function . minimumKnapsackProblem(C, w, W) Solve minimum knapsack problem using vector of costs C , weights w and overall weight limit W . source # RobRecSolver.getKnapsackConstraints \u2014 Function . getKnapsackConstraints(w, W) Return a list of constraints defining a set of feasible solutions of a minimum knapsack problem. Each constraint is function with one parameter, which is variable of a mathematical programming model. source # RobRecSolver.minimumAssignmentProblem \u2014 Function . \" minimumAssignmentProblem(C) Solve minimum assignment problem using vector of costs C . source # RobRecSolver.getAssignmentConstraints \u2014 Function . getAssignmentConstraints(m) Return a list of constraints defining a set of feasible solutions of a minimum assignment problem. Each constraint is function with one parameter, which is variable of a mathematical programming model. source Testing Framework # RobRecSolver.Experiments \u2014 Module . RobRecSolver.Experiments is a module containing all of the code regarding conduction of experiments. source # RobRecSolver.Experiments.generateData \u2014 Function . generateData(problemDescriptor::ProblemDescriptor) Helper function designed to generate experiment data for each problem under consideration. It returns a tuple (C, c, d, \u0393, X) where C is a vector of nonnegative first stage costs c is a vector of a nonnegative nominal second stage costs d is a vector of maximal deviations of the costs from their nominal values \u0393 is a budget, or the amount of uncertainty, which can be allocated to the second stage costs X is a set of feasible solutions represented as a list functions, each of which accepts a list of JuMP variables as an argument and returns a JuMP linear constraint source # RobRecSolver.Experiments.runExperiments \u2014 Function . runExperiments(ns::Array{Integer}, ms::Array{Integer}; \u03b1s = collect(0.1:0.1:0.9), numberOfInstances = 5) Entry point of experiments. This function runs experiments for minimum knapsack problem with problem size n specified by the list ns and minimum assignment problem with problem size m specified by the list ms . Optional argument \u03b1s specify a list of parameters defining neighbourhood of some solution $x$ and optional argument numberOfInstances specify number of problem instances to be generated for each value of alpha . Examples: julia> using RobRecSolver.Experiments julia> runExperiments([100, 400, 1000], [10, 25, 100]) source # RobRecSolver.Experiments.runKnapsackExperiments \u2014 Function . runKnapsackExperiments(ns; \u03b1s = collect(0.1:0.1:0.9), numberOfInstances = 5) Runs experiments for minimum knapsack problem. source # RobRecSolver.Experiments.runAssignmentExperiments \u2014 Function . runAssignmentExperiments(ms; \u03b1s = collect(0.1:0.1:0.9), numberOfInstances = 5) Runs experiments for minimum assignment problem. source # RobRecSolver.Experiments.exportKnapsackResults \u2014 Function . exportKnapsackResults(problemDescriptor, \u03b1s, results) Saves results of minimum knapsack problem experiments to CSV files and as PDF plots. Arguments problemDescriptor::ProblemDescriptor : implementation of ProblemDescriptor for this problem. \u03b1s::Array{Integer, 1} : list of values of \u03b1. results::Array{Float64, 1} : three-dimentional array of results, where first dimention specify problem, second dimention specify ratios or times results, the third one contain results for each value of \u03b1. source # RobRecSolver.Experiments.exportAssignmentResults \u2014 Function . exportAssignmentResults(problemDescriptor, \u03b1s, results) Saves results of minimum assignment problem experiments to CSV files and as PDF plots. Arguments problemDescriptor::ProblemDescriptor : implementation of ProblemDescriptor for this problem. \u03b1s::Array{Integer, 1} : list of values of \u03b1. results::Array{Float64, 1} : three-dimentional array of results, where first dimention specify problem, second dimention specify ratios or times results, the third one contain results for each value of \u03b1. source # RobRecSolver.Experiments.saveCsv \u2014 Function . saveCsv(filename, data, columnNames) Saves data described by columnNames to CSV file with name filename . Examples: julia> Experiments.saveCsv(\"item_prices.csv\", [\"milk\" 100; \"ham\" 250], [\"item\", \"price\"]) source # RobRecSolver.Experiments.drawAndSavePlot \u2014 Function . drawAndSavePlot(filename, x, ys, xlabel, ylabel, yslabels; linewidth=2, linestyles = [:solid :dash :dashdot :dot :solid], shape = [:diamond :pentagon :star4 :utriangle :square], palette=cgrad([:black, :grey]), annotations = []) Draws plot and saves it to PDF file with name filename . Here x is a values of 0X axis, ys is a columns of series, xlabel is label of 0X axis, ylabel is label of 0Y axis and yslabels is a labels of individual series. The rest of arguments is self-descriptive. Examples: julia> Experiments.drawAndSavePlot(\"plot.pdf\", [0.1, 0.2, 0.3], [21, 15, 12], \"\u03b1\", \"average time (s)\", \"m=100\") source Utilities The functions below allow customize package parameters like solver time limits or logging for different algorithms. # RobRecSolver.loadProperties \u2014 Function . loadProperties() Loads properties stored in an INI file from the specified file location. To change default location set ROBRECSOLVER_CONFIG environment variable either in Julia REPL or in ~/.julia/config/startup.jl and then reload RobRecSolver package: julia> ENV[ROBRECSOLVER_CONFIG] = \"<path_to_file>\" julia> Pkg.reload(\"RobRecSolver\") Use default properties file Pkg.dir(\"RobRecSolver\")/conf/config.ini as a reference. In order to reset changes simply delete environment variable and reload RobRecSolver package. source # RobRecSolver.getProperty \u2014 Function . getProperty(parameter[, parameterType, section]) Get value for key of name parameter of type parameterType from section section from either default properties files or the one specified with a path in ROBRECSOLVER_CONFIG. Argument parameterType defaults to Int and section defaults to main . source","title":"Home"},{"location":"#robrecsolverjl-documentation","text":"RobRecSolver.jl Documentation Algorithms Experiments Utilities # RobRecSolver \u2014 Module . RobRecSolver is a Julia programming language package developed to test performance of algorithms proposed in Robust recoverable 0-1 optimization problems under polyhedral uncertainty (Mikita Hradovich, Adam Kasperski, Pawel Zielinski) which is available as preprint on arxiv.org . This work will later be referenced as publication . source","title":"RobRecSolver.jl Documentation"},{"location":"#algorithms","text":"There is a number of types and helper functions defined to facilitate implementation of algorithms of algorithms described in paper. # RobRecSolver.ProblemDescriptor \u2014 Type . Base type for all problem descriptors. It is expected to has the following fields: n : the size of the problem. saneComputationLimit : maximum size of the problem for which computing results for adversarial lower bound, recoverable lower bound, selection lower bound or lagrangian lower bound makes sense. equalCardinalityProperty : specifies if problem possess equal cardinality property. cardinality : cardinality of the problem if any. source # RobRecSolver.KnapsackProblemDescriptor \u2014 Type . KnapsackProblemDescriptor is an implementation ProblemDescriptor for minmium knapsack problem. source # RobRecSolver.AssignmentProblemDescriptor \u2014 Type . AssignmentProblemDescriptor is an implementation ProblemDescriptor for minmium assignment problem. source # RobRecSolver.getProblemSize \u2014 Function . getProblemSize(pd::ProblemDescriptor) Returns the size of the problem. Arguments pd : instance of ProblemDescriptor source # RobRecSolver.getSaneComputationLimit \u2014 Function . getSaneComputationLimit(pd::ProblemDescriptor) Returns maximum size of the problem for which computing results for adversarial lower bound, recoverable lower bound, selection lower bound or lagrangian lower bound makes sense. Arguments pd : instance of ProblemDescriptor source # RobRecSolver.hasEqualCardinalityProperty \u2014 Function . hasEqualCardinalityProperty(pd::ProblemDescriptor) Returns whether the problem possess equal cardinality property. Arguments pd : instance of ProblemDescriptor source # RobRecSolver.getCardinality \u2014 Function . getCardinality(pd::ProblemDescriptor) Returns cardinality of the problem if any. Arguments pd : instance of ProblemDescriptor source # RobRecSolver.initialScenario \u2014 Function . initialScenario(c, d, \u0393) Returns a good initial scenario $c_0$. It is used in computation of evaluationProblem and adversarialProblem . Check section 5.1 Adversarial lower bound of publication for more information about this algorithm. Arguments c : vector of nonnegative nominal second stage costs. d : vector of maximal deviations of the costs from their nominal values. \u0393 : budget, or the amount of uncertainty, which can be allocated to the second stage costs source","title":"Algorithms"},{"location":"#incremental-problem","text":"# RobRecSolver.incrementalProblem \u2014 Function . incrementalProblem(c, \u03b1, x, X, pd) Solves incremental problem with specified costs c , parameter $\u03b1 \\in [0, 1]$, first stage solutions x and a list of constraints X defining a set of feasible solutions. It is subproblem of of evaluationProblem and adversarialProblem . Check section 4 Solving the problems by MIP formulations of publication for more information about this algorithm. Arguments c : is a vector of a nonnegative nominal second stage costs. \u03b1 : fixed number belonging to $[0, 1]$ x : first stage solution. X : is a set of feasible solutions represented as a list functions, each of which accepts a list of JuMP variables as an argument and returns a JuMP linear constraint. pd : instance of ProblemDescriptor source","title":"Incremental Problem"},{"location":"#evaluation-problem","text":"# RobRecSolver.evaluationProblem \u2014 Function . evaluationProblem(C, c, d, \u0393, \u03b1, x, X, pd) Computes Eval with accuracy \u03f5. Check section 4 Solving the problems by MIP formulations of publication for more information about this algorithm. Arguments C : is a vector of nonnegative first stage costs. c : is a vector of a nonnegative nominal second stage costs. d : is a vector of maximal deviations of the costs from their nominal values. \u0393 : is a budget, or the amount of uncertainty, which can be allocated to the second stage costs. X : is a set of feasible solutions represented as a list functions, each of which accepts a list of JuMP variables as an argument and returns a JuMP linear constraint. \u03b1 : fixed number belonging to $[0, 1]$ pd : instance of ProblemDescriptor source","title":"Evaluation Problem"},{"location":"#recoverable-problem","text":"# RobRecSolver.recoverableProblem \u2014 Function . recoverableProblem(C, c, X, \u03b1, dg) Solves recoverable problem $REC(c) = min_{x \\in X} min_{y \\in X^{\\alpha}_x} (Cx + cy)$. Check section 4 Solving the problems by MIP formulations of publication for more information about this algorithm. Arguments C : is a vector of nonnegative first stage costs. c : is a vector of a nonnegative nominal second stage costs. X : is a set of feasible solutions represented as a list functions, each of which accepts a list of JuMP variables as an argument and returns a JuMP linear constraint. \u03b1 : fixed number belonging to $[0, 1]$ pd : instance of ProblemDescriptor source","title":"Recoverable Problem"},{"location":"#adversarial-problem","text":"# RobRecSolver.adversarialProblem \u2014 Function . adversarialProblem(C, c, d, \u0393, X, \u03b1, pd) Computes Adv with accuracy \u03f5. Check section 5.1 Adversarial lower bound of publication for more information about this algorithm. Arguments C : is a vector of nonnegative first stage costs. c : is a vector of a nonnegative nominal second stage costs. d : is a vector of maximal deviations of the costs from their nominal values. \u0393 : is a budget, or the amount of uncertainty, which can be allocated to the second stage costs. X : is a set of feasible solutions represented as a list functions, each of which accepts a list of JuMP variables as an argument and returns a JuMP linear constraint. \u03b1 : fixed number belonging to $[0, 1]$ pd : instance of ProblemDescriptor source","title":"Adversarial Problem"},{"location":"#selection-lower-bound","text":"# RobRecSolver.selectionLowerBound \u2014 Function . selectionLowerBound(C, c, d, \u0393, X, \u03b1, dg) Computes selection lower bound. Check section 5.2 Selection lower bound of publication for more information about this algorithm. Arguments C : is a vector of nonnegative first stage costs. c : is a vector of a nonnegative nominal second stage costs. d : is a vector of maximal deviations of the costs from their nominal values. \u0393 : is a budget, or the amount of uncertainty, which can be allocated to the second stage costs. X : is a set of feasible solutions represented as a list functions, each of which accepts a list of JuMP variables as an argument and returns a JuMP linear constraint. \u03b1 : fixed number belonging to $[0, 1]$ pd : instance of ProblemDescriptor source","title":"Selection Lower Bound"},{"location":"#lagrangian-lower-bound","text":"# RobRecSolver.lagrangianLowerBound \u2014 Function . lagrangian_lower_bound(C, c, d, \u0393, X, l, dg) Computes Lagrangian lower bound. Check section 5.3 Lagrangian lower bound of publication for more information about this algorithm. Arguments C : is a vector of nonnegative first stage costs. c : is a vector of a nonnegative nominal second stage costs. d : is a vector of maximal deviations of the costs from their nominal values. \u0393 : is a budget, or the amount of uncertainty, which can be allocated to the second stage costs. X : is a set of feasible solutions represented as a list functions, each of which accepts a list of JuMP variables as an argument and returns a JuMP linear constraint. l : value of parameter $l=\\lceil m(1-\\alpha) \\rceil$ pd : instance of ProblemDescriptor source","title":"Lagrangian Lower Bound"},{"location":"#experiments","text":"","title":"Experiments"},{"location":"#problems","text":"# RobRecSolver.minimumKnapsackProblem \u2014 Function . minimumKnapsackProblem(C, w, W) Solve minimum knapsack problem using vector of costs C , weights w and overall weight limit W . source # RobRecSolver.getKnapsackConstraints \u2014 Function . getKnapsackConstraints(w, W) Return a list of constraints defining a set of feasible solutions of a minimum knapsack problem. Each constraint is function with one parameter, which is variable of a mathematical programming model. source # RobRecSolver.minimumAssignmentProblem \u2014 Function . \" minimumAssignmentProblem(C) Solve minimum assignment problem using vector of costs C . source # RobRecSolver.getAssignmentConstraints \u2014 Function . getAssignmentConstraints(m) Return a list of constraints defining a set of feasible solutions of a minimum assignment problem. Each constraint is function with one parameter, which is variable of a mathematical programming model. source","title":"Problems"},{"location":"#testing-framework","text":"# RobRecSolver.Experiments \u2014 Module . RobRecSolver.Experiments is a module containing all of the code regarding conduction of experiments. source # RobRecSolver.Experiments.generateData \u2014 Function . generateData(problemDescriptor::ProblemDescriptor) Helper function designed to generate experiment data for each problem under consideration. It returns a tuple (C, c, d, \u0393, X) where C is a vector of nonnegative first stage costs c is a vector of a nonnegative nominal second stage costs d is a vector of maximal deviations of the costs from their nominal values \u0393 is a budget, or the amount of uncertainty, which can be allocated to the second stage costs X is a set of feasible solutions represented as a list functions, each of which accepts a list of JuMP variables as an argument and returns a JuMP linear constraint source # RobRecSolver.Experiments.runExperiments \u2014 Function . runExperiments(ns::Array{Integer}, ms::Array{Integer}; \u03b1s = collect(0.1:0.1:0.9), numberOfInstances = 5) Entry point of experiments. This function runs experiments for minimum knapsack problem with problem size n specified by the list ns and minimum assignment problem with problem size m specified by the list ms . Optional argument \u03b1s specify a list of parameters defining neighbourhood of some solution $x$ and optional argument numberOfInstances specify number of problem instances to be generated for each value of alpha . Examples: julia> using RobRecSolver.Experiments julia> runExperiments([100, 400, 1000], [10, 25, 100]) source # RobRecSolver.Experiments.runKnapsackExperiments \u2014 Function . runKnapsackExperiments(ns; \u03b1s = collect(0.1:0.1:0.9), numberOfInstances = 5) Runs experiments for minimum knapsack problem. source # RobRecSolver.Experiments.runAssignmentExperiments \u2014 Function . runAssignmentExperiments(ms; \u03b1s = collect(0.1:0.1:0.9), numberOfInstances = 5) Runs experiments for minimum assignment problem. source # RobRecSolver.Experiments.exportKnapsackResults \u2014 Function . exportKnapsackResults(problemDescriptor, \u03b1s, results) Saves results of minimum knapsack problem experiments to CSV files and as PDF plots. Arguments problemDescriptor::ProblemDescriptor : implementation of ProblemDescriptor for this problem. \u03b1s::Array{Integer, 1} : list of values of \u03b1. results::Array{Float64, 1} : three-dimentional array of results, where first dimention specify problem, second dimention specify ratios or times results, the third one contain results for each value of \u03b1. source # RobRecSolver.Experiments.exportAssignmentResults \u2014 Function . exportAssignmentResults(problemDescriptor, \u03b1s, results) Saves results of minimum assignment problem experiments to CSV files and as PDF plots. Arguments problemDescriptor::ProblemDescriptor : implementation of ProblemDescriptor for this problem. \u03b1s::Array{Integer, 1} : list of values of \u03b1. results::Array{Float64, 1} : three-dimentional array of results, where first dimention specify problem, second dimention specify ratios or times results, the third one contain results for each value of \u03b1. source # RobRecSolver.Experiments.saveCsv \u2014 Function . saveCsv(filename, data, columnNames) Saves data described by columnNames to CSV file with name filename . Examples: julia> Experiments.saveCsv(\"item_prices.csv\", [\"milk\" 100; \"ham\" 250], [\"item\", \"price\"]) source # RobRecSolver.Experiments.drawAndSavePlot \u2014 Function . drawAndSavePlot(filename, x, ys, xlabel, ylabel, yslabels; linewidth=2, linestyles = [:solid :dash :dashdot :dot :solid], shape = [:diamond :pentagon :star4 :utriangle :square], palette=cgrad([:black, :grey]), annotations = []) Draws plot and saves it to PDF file with name filename . Here x is a values of 0X axis, ys is a columns of series, xlabel is label of 0X axis, ylabel is label of 0Y axis and yslabels is a labels of individual series. The rest of arguments is self-descriptive. Examples: julia> Experiments.drawAndSavePlot(\"plot.pdf\", [0.1, 0.2, 0.3], [21, 15, 12], \"\u03b1\", \"average time (s)\", \"m=100\") source","title":"Testing Framework"},{"location":"#utilities","text":"The functions below allow customize package parameters like solver time limits or logging for different algorithms. # RobRecSolver.loadProperties \u2014 Function . loadProperties() Loads properties stored in an INI file from the specified file location. To change default location set ROBRECSOLVER_CONFIG environment variable either in Julia REPL or in ~/.julia/config/startup.jl and then reload RobRecSolver package: julia> ENV[ROBRECSOLVER_CONFIG] = \"<path_to_file>\" julia> Pkg.reload(\"RobRecSolver\") Use default properties file Pkg.dir(\"RobRecSolver\")/conf/config.ini as a reference. In order to reset changes simply delete environment variable and reload RobRecSolver package. source # RobRecSolver.getProperty \u2014 Function . getProperty(parameter[, parameterType, section]) Get value for key of name parameter of type parameterType from section section from either default properties files or the one specified with a path in ROBRECSOLVER_CONFIG. Argument parameterType defaults to Int and section defaults to main . source","title":"Utilities"}]}